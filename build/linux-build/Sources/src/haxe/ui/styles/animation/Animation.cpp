// Generated by Haxe 4.0.5
#include <hxcpp.h>

#ifndef INCLUDED_Reflect
#include <hxinc/Reflect.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <hxinc/haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <hxinc/haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_Dimension
#include <hxinc/haxe/ui/styles/Dimension.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_EasingFunction
#include <hxinc/haxe/ui/styles/EasingFunction.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_Value
#include <hxinc/haxe/ui/styles/Value.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_animation_Animation
#include <hxinc/haxe/ui/styles/animation/Animation.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_animation_AnimationOptions
#include <hxinc/haxe/ui/styles/animation/AnimationOptions.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_animation_KeyFrame
#include <hxinc/haxe/ui/styles/animation/KeyFrame.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_elements_AnimationKeyFrame
#include <hxinc/haxe/ui/styles/elements/AnimationKeyFrame.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_elements_AnimationKeyFrames
#include <hxinc/haxe/ui/styles/elements/AnimationKeyFrames.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_elements_Directive
#include <hxinc/haxe/ui/styles/elements/Directive.h>
#endif
#ifndef INCLUDED_haxe_ui_util_StyleUtil
#include <hxinc/haxe/ui/util/StyleUtil.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_46_new,"haxe.ui.styles.animation.Animation","new",0x0e81cf32,"haxe.ui.styles.animation.Animation.new","haxe/ui/styles/animation/Animation.hx",46,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_159_run,"haxe.ui.styles.animation.Animation","run",0x0e84e61d,"haxe.ui.styles.animation.Animation.run","haxe/ui/styles/animation/Animation.hx",159,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_178_stop,"haxe.ui.styles.animation.Animation","stop",0xa66ce8f0,"haxe.ui.styles.animation.Animation.stop","haxe/ui/styles/animation/Animation.hx",178,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_206_get_keyframeCount,"haxe.ui.styles.animation.Animation","get_keyframeCount",0xb6ec756a,"haxe.ui.styles.animation.Animation.get_keyframeCount","haxe/ui/styles/animation/Animation.hx",206,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_209_get_currentKeyFrame,"haxe.ui.styles.animation.Animation","get_currentKeyFrame",0xf8d5e950,"haxe.ui.styles.animation.Animation.get_currentKeyFrame","haxe/ui/styles/animation/Animation.hx",209,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_212__initialize,"haxe.ui.styles.animation.Animation","_initialize",0xd2a91f41,"haxe.ui.styles.animation.Animation._initialize","haxe/ui/styles/animation/Animation.hx",212,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_267__runNextKeyframe,"haxe.ui.styles.animation.Animation","_runNextKeyframe",0xe343fa9b,"haxe.ui.styles.animation.Animation._runNextKeyframe","haxe/ui/styles/animation/Animation.hx",267,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_287__runNextKeyframe,"haxe.ui.styles.animation.Animation","_runNextKeyframe",0xe343fa9b,"haxe.ui.styles.animation.Animation._runNextKeyframe","haxe/ui/styles/animation/Animation.hx",287,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_291__addAlternateKeyframes,"haxe.ui.styles.animation.Animation","_addAlternateKeyframes",0x19fb721b,"haxe.ui.styles.animation.Animation._addAlternateKeyframes","haxe/ui/styles/animation/Animation.hx",291,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_303__reverseCurrentKeyframes,"haxe.ui.styles.animation.Animation","_reverseCurrentKeyframes",0x839197bd,"haxe.ui.styles.animation.Animation._reverseCurrentKeyframes","haxe/ui/styles/animation/Animation.hx",303,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_312__getReverseEasingFunction,"haxe.ui.styles.animation.Animation","_getReverseEasingFunction",0xc105f0e0,"haxe.ui.styles.animation.Animation._getReverseEasingFunction","haxe/ui/styles/animation/Animation.hx",312,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_319__saveState,"haxe.ui.styles.animation.Animation","_saveState",0x286a58c3,"haxe.ui.styles.animation.Animation._saveState","haxe/ui/styles/animation/Animation.hx",319,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_338__restoreState,"haxe.ui.styles.animation.Animation","_restoreState",0x90435014,"haxe.ui.styles.animation.Animation._restoreState","haxe/ui/styles/animation/Animation.hx",338,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_353__shouldRestoreState,"haxe.ui.styles.animation.Animation","_shouldRestoreState",0x2225ffa7,"haxe.ui.styles.animation.Animation._shouldRestoreState","haxe/ui/styles/animation/Animation.hx",353,0x1e08c820)
HX_LOCAL_STACK_FRAME(_hx_pos_9f0e0ca4bc4bda73_50_createWithKeyFrames,"haxe.ui.styles.animation.Animation","createWithKeyFrames",0xfc4b25f5,"haxe.ui.styles.animation.Animation.createWithKeyFrames","haxe/ui/styles/animation/Animation.hx",50,0x1e08c820)
namespace haxe{
namespace ui{
namespace styles{
namespace animation{

void Animation_obj::__construct( ::Dynamic target, ::haxe::ui::styles::animation::AnimationOptions options){
            	HX_GC_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_46_new)
HXLINE( 202)		this->_initialized = false;
HXLINE( 200)		this->_currentIterationCount = -1;
HXLINE( 199)		this->_currentKeyFrameIndex = -1;
HXLINE( 121)		this->iterationCount = 1;
HXLINE( 116)		this->_hx_set_fillMode(HX_CTX, HX_("forwards",0e,ab,ba,2b));
HXLINE( 109)		this->_hx_set_easingFunction(HX_CTX, ::haxe::ui::styles::animation::AnimationOptions_obj::DEFAULT_EASING_FUNCTION);
HXLINE( 102)		this->duration = ((Float)0);
HXLINE(  97)		this->_hx_set_direction(HX_CTX, HX_("normal",27,72,69,30));
HXLINE(  90)		this->delay = ((Float)0);
HXLINE( 144)		this->_hx_set_target(HX_CTX, target);
HXLINE( 146)		if (hx::IsNotNull( options )) {
HXLINE( 147)			if (hx::IsNotNull( options->duration )) {
HXLINE( 147)				this->duration = ( (Float)(options->duration) );
            			}
HXLINE( 148)			if (hx::IsNotNull( options->easingFunction )) {
HXLINE( 148)				this->_hx_set_easingFunction(HX_CTX, options->easingFunction);
            			}
HXLINE( 149)			if (hx::IsNotNull( options->delay )) {
HXLINE( 149)				this->delay = ( (Float)(options->delay) );
            			}
HXLINE( 150)			if (hx::IsNotNull( options->iterationCount )) {
HXLINE( 150)				this->iterationCount = ( (int)(options->iterationCount) );
            			}
HXLINE( 151)			if (hx::IsNotNull( options->direction )) {
HXLINE( 151)				this->_hx_set_direction(HX_CTX, options->direction);
            			}
HXLINE( 152)			if (hx::IsNotNull( options->fillMode )) {
HXLINE( 152)				this->_hx_set_fillMode(HX_CTX, options->fillMode);
            			}
            		}
            	}

Dynamic Animation_obj::__CreateEmpty() { return new Animation_obj; }

void *Animation_obj::_hx_vtable = 0;

Dynamic Animation_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Animation_obj > _hx_result = new Animation_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Animation_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7e072e7c;
}

void Animation_obj::run( ::Dynamic onFinish){
            	HX_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_159_run)
HXLINE( 160)		bool _hx_tmp;
HXDLIN( 160)		if ((this->get_keyframeCount() != 0)) {
HXLINE( 160)			_hx_tmp = this->running;
            		}
            		else {
HXLINE( 160)			_hx_tmp = true;
            		}
HXDLIN( 160)		if (_hx_tmp) {
HXLINE( 161)			return;
            		}
HXLINE( 164)		if (!(this->_initialized)) {
HXLINE( 165)			this->_initialize();
            		}
HXLINE( 168)		this->_currentKeyFrameIndex = -1;
HXLINE( 169)		this->_currentIterationCount = 0;
HXLINE( 170)		this->running = true;
HXLINE( 171)		this->_saveState();
HXLINE( 172)		this->_runNextKeyframe(onFinish);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Animation_obj,run,(void))

void Animation_obj::stop(){
            	HX_GC_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_178_stop)
HXLINE( 179)		if ((this->running == false)) {
HXLINE( 180)			return;
            		}
HXLINE( 183)		this->running = false;
HXLINE( 185)		 ::haxe::ui::styles::animation::KeyFrame currentKF = this->get_currentKeyFrame();
HXLINE( 186)		if (hx::IsNotNull( currentKF )) {
HXLINE( 187)			currentKF->stop();
HXLINE( 188)			this->_currentKeyFrameIndex = -1;
            		}
HXLINE( 191)		this->_hx_set__keyframes(HX_CTX, null());
HXLINE( 193)		this->_restoreState();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,stop,(void))

int Animation_obj::get_keyframeCount(){
            	HX_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_206_get_keyframeCount)
HXDLIN( 206)		if (hx::IsNull( this->_keyframes )) {
HXDLIN( 206)			return 0;
            		}
            		else {
HXDLIN( 206)			return this->_keyframes->length;
            		}
HXDLIN( 206)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,get_keyframeCount,return )

 ::haxe::ui::styles::animation::KeyFrame Animation_obj::get_currentKeyFrame(){
            	HX_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_209_get_currentKeyFrame)
HXDLIN( 209)		if ((this->_currentKeyFrameIndex >= 0)) {
HXDLIN( 209)			return this->_keyframes->__get(this->_currentKeyFrameIndex).StaticCast<  ::haxe::ui::styles::animation::KeyFrame >();
            		}
            		else {
HXDLIN( 209)			return null();
            		}
HXDLIN( 209)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,get_currentKeyFrame,return )

void Animation_obj::_initialize(){
            	HX_GC_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_212__initialize)
HXLINE( 213)		::String _hx_switch_0 = this->direction;
            		if (  (_hx_switch_0==HX_("alternate",3a,c9,33,35)) ){
HXLINE( 219)			this->_addAlternateKeyframes();
HXDLIN( 219)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==HX_("alternate-reverse",cf,db,30,9f)) ){
HXLINE( 221)			this->_reverseCurrentKeyframes();
HXLINE( 222)			this->_addAlternateKeyframes();
HXLINE( 220)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==HX_("normal",27,72,69,30)) ){
HXLINE( 214)			goto _hx_goto_5;
            		}
            		if (  (_hx_switch_0==HX_("reverse",22,39,fc,1a)) ){
HXLINE( 217)			this->_reverseCurrentKeyframes();
HXDLIN( 217)			goto _hx_goto_5;
            		}
            		_hx_goto_5:;
HXLINE( 225)		Float currentTime = ( (Float)(0) );
HXLINE( 226)		{
HXLINE( 226)			int _g1 = 0;
HXDLIN( 226)			::Array< ::Dynamic> _g2 = this->_keyframes;
HXDLIN( 226)			while((_g1 < _g2->length)){
HXLINE( 226)				 ::haxe::ui::styles::animation::KeyFrame keyframe = _g2->__get(_g1).StaticCast<  ::haxe::ui::styles::animation::KeyFrame >();
HXDLIN( 226)				_g1 = (_g1 + 1);
HXLINE( 227)				::String _hx_switch_1 = this->direction;
            				if (  (_hx_switch_1==HX_("alternate-reverse",cf,db,30,9f)) ||  (_hx_switch_1==HX_("reverse",22,39,fc,1a)) ){
HXLINE( 231)					keyframe->time = (( (Float)(1) ) - keyframe->time);
HXDLIN( 231)					goto _hx_goto_7;
            				}
            				if (  (_hx_switch_1==HX_("alternate",3a,c9,33,35)) ||  (_hx_switch_1==HX_("normal",27,72,69,30)) ){
HXLINE( 228)					goto _hx_goto_7;
            				}
            				_hx_goto_7:;
HXLINE( 234)				keyframe->time = ((this->duration * keyframe->time) - currentTime);
HXLINE( 235)				currentTime = (currentTime + keyframe->time);
            			}
            		}
HXLINE( 238)		if ((this->delay > 0)) {
HXLINE( 239)			 ::haxe::ui::styles::animation::KeyFrame keyframe1 =  ::haxe::ui::styles::animation::KeyFrame_obj::__alloc( HX_CTX );
HXLINE( 240)			keyframe1->time = this->delay;
HXLINE( 241)			keyframe1->_hx_set_easingFunction(HX_CTX, this->easingFunction);
HXLINE( 242)			this->_keyframes->unshift(keyframe1);
            		}
            		else {
HXLINE( 243)			if ((this->delay < 0)) {
HXLINE( 245)				currentTime = ( (Float)(0) );
HXLINE( 246)				 ::haxe::ui::styles::animation::KeyFrame lastKeyframe = null();
HXLINE( 247)				while((this->_keyframes->length > 0)){
HXLINE( 248)					 ::haxe::ui::styles::animation::KeyFrame keyframe2 = this->_keyframes->__get(0).StaticCast<  ::haxe::ui::styles::animation::KeyFrame >();
HXLINE( 249)					currentTime = (currentTime - keyframe2->time);
HXLINE( 250)					if ((currentTime >= this->delay)) {
HXLINE( 251)						lastKeyframe = keyframe2;
HXLINE( 252)						this->_keyframes->removeRange(0,1);
            					}
            					else {
HXLINE( 254)						keyframe2->delay = -(((currentTime - this->delay) + keyframe2->time));
HXLINE( 255)						if (hx::IsNotNull( lastKeyframe )) {
HXLINE( 256)							lastKeyframe->time = ( (Float)(0) );
HXLINE( 257)							this->_keyframes->unshift(lastKeyframe);
            						}
HXLINE( 259)						goto _hx_goto_8;
            					}
            				}
            				_hx_goto_8:;
            			}
            		}
HXLINE( 264)		this->_initialized = true;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,_initialize,(void))

void Animation_obj::_runNextKeyframe( ::Dynamic onFinish){
            	HX_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_267__runNextKeyframe)
HXLINE( 268)		if ((this->running == false)) {
HXLINE( 269)			return;
            		}
HXLINE( 272)		if ((++this->_currentKeyFrameIndex >= this->_keyframes->length)) {
HXLINE( 273)			this->_currentKeyFrameIndex = -1;
HXLINE( 274)			this->_restoreState();
HXLINE( 276)			bool _hx_tmp;
HXDLIN( 276)			if ((this->iterationCount != -1)) {
HXLINE( 276)				_hx_tmp = (++this->_currentIterationCount < this->iterationCount);
            			}
            			else {
HXLINE( 276)				_hx_tmp = true;
            			}
HXDLIN( 276)			if (_hx_tmp) {
HXLINE( 277)				this->_saveState();
HXLINE( 278)				this->_runNextKeyframe(onFinish);
            			}
            			else {
HXLINE( 280)				this->running = false;
HXLINE( 281)				if (hx::IsNotNull( onFinish )) {
HXLINE( 282)					onFinish();
            				}
            			}
HXLINE( 285)			return;
            		}
            		else {
            			HX_BEGIN_LOCAL_FUNC_S2(hx::LocalFunc,_hx_Closure_0, ::Dynamic,f, ::Dynamic,onFinish1) HXARGC(0)
            			void _hx_run(){
            				HX_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_287__runNextKeyframe)
HXLINE( 287)				f(onFinish1);
            			}
            			HX_END_LOCAL_FUNC0((void))

HXLINE( 287)			 ::Dynamic f = this->_runNextKeyframe_dyn();
HXDLIN( 287)			 ::Dynamic onFinish1 = onFinish;
HXDLIN( 287)			 ::Dynamic _hx_tmp1 =  ::Dynamic(new _hx_Closure_0(f,onFinish1));
HXDLIN( 287)			this->get_currentKeyFrame()->run(this->target,_hx_tmp1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Animation_obj,_runNextKeyframe,(void))

void Animation_obj::_addAlternateKeyframes(){
            	HX_GC_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_291__addAlternateKeyframes)
HXLINE( 292)		int i = this->_keyframes->length;
HXLINE( 293)		while(true){
HXLINE( 293)			i = (i - 1);
HXDLIN( 293)			if (!((i >= 0))) {
HXLINE( 293)				goto _hx_goto_12;
            			}
HXLINE( 294)			 ::haxe::ui::styles::animation::KeyFrame keyframe = this->_keyframes->__get(i).StaticCast<  ::haxe::ui::styles::animation::KeyFrame >();
HXLINE( 295)			 ::haxe::ui::styles::animation::KeyFrame newKeyframe =  ::haxe::ui::styles::animation::KeyFrame_obj::__alloc( HX_CTX );
HXLINE( 296)			newKeyframe->time = (( (Float)(1) ) - keyframe->time);
HXLINE( 297)			newKeyframe->_hx_set_easingFunction(HX_CTX, this->_getReverseEasingFunction(keyframe->easingFunction));
HXLINE( 298)			newKeyframe->_hx_set_directives(HX_CTX, keyframe->directives);
HXLINE( 299)			this->_keyframes->push(newKeyframe);
            		}
            		_hx_goto_12:;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,_addAlternateKeyframes,(void))

void Animation_obj::_reverseCurrentKeyframes(){
            	HX_GC_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_303__reverseCurrentKeyframes)
HXLINE( 304)		this->_keyframes->reverse();
HXLINE( 305)		 ::haxe::ui::styles::EasingFunction func = this->_getReverseEasingFunction(this->easingFunction);
HXLINE( 306)		{
HXLINE( 306)			int _g = 0;
HXDLIN( 306)			::Array< ::Dynamic> _g1 = this->_keyframes;
HXDLIN( 306)			while((_g < _g1->length)){
HXLINE( 306)				 ::haxe::ui::styles::animation::KeyFrame keyframe = _g1->__get(_g).StaticCast<  ::haxe::ui::styles::animation::KeyFrame >();
HXDLIN( 306)				_g = (_g + 1);
HXLINE( 307)				keyframe->_hx_set_easingFunction(HX_CTX, func);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,_reverseCurrentKeyframes,(void))

 ::haxe::ui::styles::EasingFunction Animation_obj::_getReverseEasingFunction( ::haxe::ui::styles::EasingFunction easingFunction){
            	HX_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_312__getReverseEasingFunction)
HXDLIN( 312)		switch((int)(easingFunction->_hx_getIndex())){
            			case (int)2: {
HXLINE( 314)				return ::haxe::ui::styles::EasingFunction_obj::EASE_OUT_dyn();
            			}
            			break;
            			case (int)3: {
HXLINE( 313)				return ::haxe::ui::styles::EasingFunction_obj::EASE_IN_dyn();
            			}
            			break;
            			default:{
HXLINE( 315)				return easingFunction;
            			}
            		}
HXLINE( 312)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Animation_obj,_getReverseEasingFunction,return )

void Animation_obj::_saveState(){
            	HX_GC_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_319__saveState)
HXLINE( 320)		if (!(this->_shouldRestoreState())) {
HXLINE( 321)			return;
            		}
HXLINE( 324)		if (hx::IsNull( this->_initialState )) {
HXLINE( 325)			this->_hx_set__initialState(HX_CTX,  ::haxe::ds::StringMap_obj::__alloc( HX_CTX ));
            		}
HXLINE( 328)		{
HXLINE( 328)			int _g = 0;
HXDLIN( 328)			::Array< ::Dynamic> _g1 = this->_keyframes;
HXDLIN( 328)			while((_g < _g1->length)){
HXLINE( 328)				 ::haxe::ui::styles::animation::KeyFrame keyframe = _g1->__get(_g).StaticCast<  ::haxe::ui::styles::animation::KeyFrame >();
HXDLIN( 328)				_g = (_g + 1);
HXLINE( 329)				{
HXLINE( 329)					int _g2 = 0;
HXDLIN( 329)					::Array< ::Dynamic> _g11 = keyframe->directives;
HXDLIN( 329)					while((_g2 < _g11->length)){
HXLINE( 329)						 ::haxe::ui::styles::elements::Directive directive = _g11->__get(_g2).StaticCast<  ::haxe::ui::styles::elements::Directive >();
HXDLIN( 329)						_g2 = (_g2 + 1);
HXLINE( 330)						::String property = ::haxe::ui::util::StyleUtil_obj::styleProperty2ComponentProperty(directive->directive);
HXLINE( 331)						if (!(this->_initialState->exists(property))) {
HXLINE( 332)							::Dynamic this1 = this->_initialState;
HXDLIN( 332)							( ( ::haxe::ds::StringMap)(this1) )->set(property,::Reflect_obj::getProperty(this->target,property));
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,_saveState,(void))

void Animation_obj::_restoreState(){
            	HX_GC_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_338__restoreState)
HXLINE( 339)		if (!(this->_shouldRestoreState())) {
HXLINE( 340)			return;
            		}
HXLINE( 343)		if (hx::IsNotNull( this->_initialState )) {
HXLINE( 344)			{
HXLINE( 344)				 ::Dynamic property = this->_initialState->keys();
HXDLIN( 344)				while(( (bool)(property->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 344)					::String property1 = ( (::String)(property->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 345)					 ::Dynamic _hx_tmp = this->target;
HXDLIN( 345)					::Reflect_obj::setProperty(_hx_tmp,property1,this->_initialState->get(property1));
            				}
            			}
HXLINE( 348)			this->_hx_set__initialState(HX_CTX, null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,_restoreState,(void))

bool Animation_obj::_shouldRestoreState(){
            	HX_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_353__shouldRestoreState)
HXDLIN( 353)		bool _hx_tmp;
HXDLIN( 353)		if ((this->fillMode != HX_("none",b8,12,0a,49))) {
HXLINE( 354)			bool _hx_tmp1;
HXDLIN( 354)			if ((this->fillMode == HX_("forwards",0e,ab,ba,2b))) {
HXLINE( 354)				_hx_tmp1 = (this->direction != HX_("normal",27,72,69,30));
            			}
            			else {
HXLINE( 354)				_hx_tmp1 = false;
            			}
HXDLIN( 354)			if (_hx_tmp1) {
HXDLIN( 353)				_hx_tmp = (this->direction != HX_("alternate",3a,c9,33,35));
            			}
            			else {
HXDLIN( 353)				_hx_tmp = false;
            			}
            		}
            		else {
HXDLIN( 353)			_hx_tmp = true;
            		}
HXDLIN( 353)		if (!(_hx_tmp)) {
HXLINE( 355)			bool _hx_tmp2;
HXDLIN( 355)			if ((this->fillMode == HX_("backwards",30,8b,a7,0e))) {
HXLINE( 355)				_hx_tmp2 = (this->direction != HX_("reverse",22,39,fc,1a));
            			}
            			else {
HXLINE( 355)				_hx_tmp2 = false;
            			}
HXDLIN( 355)			if (_hx_tmp2) {
HXLINE( 355)				return (this->direction != HX_("alternate-reverse",cf,db,30,9f));
            			}
            			else {
HXLINE( 355)				return false;
            			}
            		}
            		else {
HXDLIN( 353)			return true;
            		}
HXDLIN( 353)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Animation_obj,_shouldRestoreState,return )

 ::haxe::ui::styles::animation::Animation Animation_obj::createWithKeyFrames( ::haxe::ui::styles::elements::AnimationKeyFrames animationKeyFrames, ::Dynamic target, ::haxe::ui::styles::animation::AnimationOptions options){
            	HX_GC_STACKFRAME(&_hx_pos_9f0e0ca4bc4bda73_50_createWithKeyFrames)
HXLINE(  51)		 ::haxe::ui::styles::animation::Animation animation =  ::haxe::ui::styles::animation::Animation_obj::__alloc( HX_CTX ,target,options);
HXLINE(  52)		animation->_hx_set_name(HX_CTX, animationKeyFrames->id);
HXLINE(  54)		if (hx::IsNull( animation->_keyframes )) {
HXLINE(  55)			animation->_hx_set__keyframes(HX_CTX, ::Array_obj< ::Dynamic>::__new(0));
            		}
HXLINE(  58)		{
HXLINE(  58)			int _g = 0;
HXDLIN(  58)			::Array< ::Dynamic> _g1 = animationKeyFrames->get_keyFrames();
HXDLIN(  58)			while((_g < _g1->length)){
HXLINE(  58)				 ::haxe::ui::styles::elements::AnimationKeyFrame keyFrame = _g1->__get(_g).StaticCast<  ::haxe::ui::styles::elements::AnimationKeyFrame >();
HXDLIN(  58)				_g = (_g + 1);
HXLINE(  59)				 ::haxe::ui::styles::animation::KeyFrame kf =  ::haxe::ui::styles::animation::KeyFrame_obj::__alloc( HX_CTX );
HXLINE(  61)				{
HXLINE(  61)					 ::haxe::ui::styles::Value _g2 = keyFrame->time;
HXDLIN(  61)					if ((_g2->_hx_getIndex() == 3)) {
HXLINE(  62)						 ::haxe::ui::styles::Dimension v = _g2->_hx_getObject(0).StaticCast<  ::haxe::ui::styles::Dimension >();
HXLINE(  63)						if ((v->_hx_getIndex() == 0)) {
HXLINE(  64)							Float p = v->_hx_getFloat(0);
HXDLIN(  64)							{
HXLINE(  65)								kf->time = (p / ( (Float)(100) ));
HXLINE(  66)								kf->_hx_set_easingFunction(HX_CTX, animation->easingFunction);
HXLINE(  67)								kf->_hx_set_directives(HX_CTX, keyFrame->directives);
HXLINE(  68)								animation->_keyframes->push(kf);
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE(  75)		return animation;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Animation_obj,createWithKeyFrames,return )


hx::ObjectPtr< Animation_obj > Animation_obj::__new( ::Dynamic target, ::haxe::ui::styles::animation::AnimationOptions options) {
	hx::ObjectPtr< Animation_obj > __this = new Animation_obj();
	__this->__construct(target,options);
	return __this;
}

hx::ObjectPtr< Animation_obj > Animation_obj::__alloc(hx::Ctx *_hx_ctx, ::Dynamic target, ::haxe::ui::styles::animation::AnimationOptions options) {
	Animation_obj *__this = (Animation_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Animation_obj), true, "haxe.ui.styles.animation.Animation"));
	*(void **)__this = Animation_obj::_hx_vtable;
	__this->__construct(target,options);
	return __this;
}

Animation_obj::Animation_obj()
{
}

void Animation_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Animation);
	HX_MARK_MEMBER_NAME(delay,"delay");
	HX_MARK_MEMBER_NAME(direction,"direction");
	HX_MARK_MEMBER_NAME(duration,"duration");
	HX_MARK_MEMBER_NAME(easingFunction,"easingFunction");
	HX_MARK_MEMBER_NAME(fillMode,"fillMode");
	HX_MARK_MEMBER_NAME(iterationCount,"iterationCount");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(running,"running");
	HX_MARK_MEMBER_NAME(target,"target");
	HX_MARK_MEMBER_NAME(_currentKeyFrameIndex,"_currentKeyFrameIndex");
	HX_MARK_MEMBER_NAME(_currentIterationCount,"_currentIterationCount");
	HX_MARK_MEMBER_NAME(_initialState,"_initialState");
	HX_MARK_MEMBER_NAME(_initialized,"_initialized");
	HX_MARK_MEMBER_NAME(_keyframes,"_keyframes");
	HX_MARK_END_CLASS();
}

void Animation_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(delay,"delay");
	HX_VISIT_MEMBER_NAME(direction,"direction");
	HX_VISIT_MEMBER_NAME(duration,"duration");
	HX_VISIT_MEMBER_NAME(easingFunction,"easingFunction");
	HX_VISIT_MEMBER_NAME(fillMode,"fillMode");
	HX_VISIT_MEMBER_NAME(iterationCount,"iterationCount");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(running,"running");
	HX_VISIT_MEMBER_NAME(target,"target");
	HX_VISIT_MEMBER_NAME(_currentKeyFrameIndex,"_currentKeyFrameIndex");
	HX_VISIT_MEMBER_NAME(_currentIterationCount,"_currentIterationCount");
	HX_VISIT_MEMBER_NAME(_initialState,"_initialState");
	HX_VISIT_MEMBER_NAME(_initialized,"_initialized");
	HX_VISIT_MEMBER_NAME(_keyframes,"_keyframes");
}

hx::Val Animation_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"run") ) { return hx::Val( run_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"stop") ) { return hx::Val( stop_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"delay") ) { return hx::Val( delay ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"target") ) { return hx::Val( target ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"running") ) { return hx::Val( running ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"duration") ) { return hx::Val( duration ); }
		if (HX_FIELD_EQ(inName,"fillMode") ) { return hx::Val( fillMode ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"direction") ) { return hx::Val( direction ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_keyframes") ) { return hx::Val( _keyframes ); }
		if (HX_FIELD_EQ(inName,"_saveState") ) { return hx::Val( _saveState_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_initialize") ) { return hx::Val( _initialize_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_initialized") ) { return hx::Val( _initialized ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"keyframeCount") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_keyframeCount() ); }
		if (HX_FIELD_EQ(inName,"_initialState") ) { return hx::Val( _initialState ); }
		if (HX_FIELD_EQ(inName,"_restoreState") ) { return hx::Val( _restoreState_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"easingFunction") ) { return hx::Val( easingFunction ); }
		if (HX_FIELD_EQ(inName,"iterationCount") ) { return hx::Val( iterationCount ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"currentKeyFrame") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_currentKeyFrame() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"_runNextKeyframe") ) { return hx::Val( _runNextKeyframe_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"get_keyframeCount") ) { return hx::Val( get_keyframeCount_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"get_currentKeyFrame") ) { return hx::Val( get_currentKeyFrame_dyn() ); }
		if (HX_FIELD_EQ(inName,"_shouldRestoreState") ) { return hx::Val( _shouldRestoreState_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"_currentKeyFrameIndex") ) { return hx::Val( _currentKeyFrameIndex ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"_currentIterationCount") ) { return hx::Val( _currentIterationCount ); }
		if (HX_FIELD_EQ(inName,"_addAlternateKeyframes") ) { return hx::Val( _addAlternateKeyframes_dyn() ); }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"_reverseCurrentKeyframes") ) { return hx::Val( _reverseCurrentKeyframes_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"_getReverseEasingFunction") ) { return hx::Val( _getReverseEasingFunction_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Animation_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 19:
		if (HX_FIELD_EQ(inName,"createWithKeyFrames") ) { outValue = createWithKeyFrames_dyn(); return true; }
	}
	return false;
}

hx::Val Animation_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"name") ) { _hx_set_name(HX_CTX_GET,inValue.Cast< ::String >()); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"delay") ) { delay=inValue.Cast< Float >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"target") ) { _hx_set_target(HX_CTX_GET,inValue.Cast<  ::Dynamic >()); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"running") ) { running=inValue.Cast< bool >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"duration") ) { duration=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"fillMode") ) { _hx_set_fillMode(HX_CTX_GET,inValue.Cast< ::String >()); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"direction") ) { _hx_set_direction(HX_CTX_GET,inValue.Cast< ::String >()); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_keyframes") ) { _hx_set__keyframes(HX_CTX_GET,inValue.Cast< ::Array< ::Dynamic> >()); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"_initialized") ) { _initialized=inValue.Cast< bool >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_initialState") ) { _hx_set__initialState(HX_CTX_GET,inValue.Cast<  ::haxe::ds::StringMap >()); return inValue; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"easingFunction") ) { _hx_set_easingFunction(HX_CTX_GET,inValue.Cast<  ::haxe::ui::styles::EasingFunction >()); return inValue; }
		if (HX_FIELD_EQ(inName,"iterationCount") ) { iterationCount=inValue.Cast< int >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"_currentKeyFrameIndex") ) { _currentKeyFrameIndex=inValue.Cast< int >(); return inValue; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"_currentIterationCount") ) { _currentIterationCount=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Animation_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("currentKeyFrame",67,d7,3e,1f));
	outFields->push(HX_("delay",83,d7,26,d7));
	outFields->push(HX_("direction",3f,62,40,10));
	outFields->push(HX_("duration",54,0f,8e,14));
	outFields->push(HX_("easingFunction",e3,d6,ae,0d));
	outFields->push(HX_("fillMode",86,cb,72,69));
	outFields->push(HX_("iterationCount",f2,c4,ce,8f));
	outFields->push(HX_("keyframeCount",c1,df,a4,2e));
	outFields->push(HX_("name",4b,72,ff,48));
	outFields->push(HX_("running",ff,6d,69,eb));
	outFields->push(HX_("target",51,f3,ec,86));
	outFields->push(HX_("_currentKeyFrameIndex",0a,08,35,89));
	outFields->push(HX_("_currentIterationCount",4c,20,b5,c7));
	outFields->push(HX_("_initialState",cc,09,8a,2a));
	outFields->push(HX_("_initialized",15,a3,19,9d));
	outFields->push(HX_("_keyframes",46,36,9b,6b));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Animation_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(Animation_obj,delay),HX_("delay",83,d7,26,d7)},
	{hx::fsString,(int)offsetof(Animation_obj,direction),HX_("direction",3f,62,40,10)},
	{hx::fsFloat,(int)offsetof(Animation_obj,duration),HX_("duration",54,0f,8e,14)},
	{hx::fsObject /*  ::haxe::ui::styles::EasingFunction */ ,(int)offsetof(Animation_obj,easingFunction),HX_("easingFunction",e3,d6,ae,0d)},
	{hx::fsString,(int)offsetof(Animation_obj,fillMode),HX_("fillMode",86,cb,72,69)},
	{hx::fsInt,(int)offsetof(Animation_obj,iterationCount),HX_("iterationCount",f2,c4,ce,8f)},
	{hx::fsString,(int)offsetof(Animation_obj,name),HX_("name",4b,72,ff,48)},
	{hx::fsBool,(int)offsetof(Animation_obj,running),HX_("running",ff,6d,69,eb)},
	{hx::fsObject /*  ::Dynamic */ ,(int)offsetof(Animation_obj,target),HX_("target",51,f3,ec,86)},
	{hx::fsInt,(int)offsetof(Animation_obj,_currentKeyFrameIndex),HX_("_currentKeyFrameIndex",0a,08,35,89)},
	{hx::fsInt,(int)offsetof(Animation_obj,_currentIterationCount),HX_("_currentIterationCount",4c,20,b5,c7)},
	{hx::fsObject /*  ::haxe::ds::StringMap */ ,(int)offsetof(Animation_obj,_initialState),HX_("_initialState",cc,09,8a,2a)},
	{hx::fsBool,(int)offsetof(Animation_obj,_initialized),HX_("_initialized",15,a3,19,9d)},
	{hx::fsObject /* ::Array< ::Dynamic> */ ,(int)offsetof(Animation_obj,_keyframes),HX_("_keyframes",46,36,9b,6b)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Animation_obj_sStaticStorageInfo = 0;
#endif

static ::String Animation_obj_sMemberFields[] = {
	HX_("delay",83,d7,26,d7),
	HX_("direction",3f,62,40,10),
	HX_("duration",54,0f,8e,14),
	HX_("easingFunction",e3,d6,ae,0d),
	HX_("fillMode",86,cb,72,69),
	HX_("iterationCount",f2,c4,ce,8f),
	HX_("name",4b,72,ff,48),
	HX_("running",ff,6d,69,eb),
	HX_("target",51,f3,ec,86),
	HX_("run",4b,e7,56,00),
	HX_("stop",02,f0,5b,4c),
	HX_("_currentKeyFrameIndex",0a,08,35,89),
	HX_("_currentIterationCount",4c,20,b5,c7),
	HX_("_initialState",cc,09,8a,2a),
	HX_("_initialized",15,a3,19,9d),
	HX_("_keyframes",46,36,9b,6b),
	HX_("get_keyframeCount",18,eb,14,35),
	HX_("get_currentKeyFrame",7e,a6,49,aa),
	HX_("_initialize",6f,fe,44,bf),
	HX_("_runNextKeyframe",ad,54,aa,5e),
	HX_("_addAlternateKeyframes",ad,a5,23,9e),
	HX_("_reverseCurrentKeyframes",cf,53,db,88),
	HX_("_getReverseEasingFunction",8e,c4,40,5c),
	HX_("_saveState",55,f9,5a,6e),
	HX_("_restoreState",c2,d6,f7,c2),
	HX_("_shouldRestoreState",d5,bc,99,d3),
	::String(null()) };

hx::Class Animation_obj::__mClass;

static ::String Animation_obj_sStaticFields[] = {
	HX_("createWithKeyFrames",23,e3,be,ad),
	::String(null())
};

void Animation_obj::__register()
{
	Animation_obj _hx_dummy;
	Animation_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("haxe.ui.styles.animation.Animation",40,0e,02,d1);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Animation_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Animation_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Animation_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Animation_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Animation_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Animation_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace ui
} // end namespace styles
} // end namespace animation
