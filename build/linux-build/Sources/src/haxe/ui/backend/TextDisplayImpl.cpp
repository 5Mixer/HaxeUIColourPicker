// Generated by Haxe 4.0.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Lambda
#include <hxinc/Lambda.h>
#endif
#ifndef INCLUDED_Std
#include <hxinc/Std.h>
#endif
#ifndef INCLUDED_haxe_ds_List
#include <hxinc/haxe/ds/List.h>
#endif
#ifndef INCLUDED_haxe_ui_Toolkit
#include <hxinc/haxe/ui/Toolkit.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_TextBase
#include <hxinc/haxe/ui/backend/TextBase.h>
#endif
#ifndef INCLUDED_haxe_ui_backend_TextDisplayImpl
#include <hxinc/haxe/ui/backend/TextDisplayImpl.h>
#endif
#ifndef INCLUDED_haxe_ui_styles_Style
#include <hxinc/haxe/ui/styles/Style.h>
#endif
#ifndef INCLUDED_kha_Kravur
#include <hxinc/kha/Kravur.h>
#endif
#ifndef INCLUDED_kha_Resource
#include <hxinc/kha/Resource.h>
#endif
#ifndef INCLUDED_kha_graphics2_Graphics
#include <hxinc/kha/graphics2/Graphics.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8071faafd25b045f_6_new,"haxe.ui.backend.TextDisplayImpl","new",0x7f5d76bb,"haxe.ui.backend.TextDisplayImpl.new","haxe/ui/backend/TextDisplayImpl.hx",6,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_21_validateStyle,"haxe.ui.backend.TextDisplayImpl","validateStyle",0xbd02aad6,"haxe.ui.backend.TextDisplayImpl.validateStyle","haxe/ui/backend/TextDisplayImpl.hx",21,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_47_validateDisplay,"haxe.ui.backend.TextDisplayImpl","validateDisplay",0xbbb7a327,"haxe.ui.backend.TextDisplayImpl.validateDisplay","haxe/ui/backend/TextDisplayImpl.hx",47,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_57_measureText,"haxe.ui.backend.TextDisplayImpl","measureText",0x0670f486,"haxe.ui.backend.TextDisplayImpl.measureText","haxe/ui/backend/TextDisplayImpl.hx",57,0xee590bf6)
HX_LOCAL_STACK_FRAME(_hx_pos_8071faafd25b045f_109_renderTo,"haxe.ui.backend.TextDisplayImpl","renderTo",0xb3922636,"haxe.ui.backend.TextDisplayImpl.renderTo","haxe/ui/backend/TextDisplayImpl.hx",109,0xee590bf6)
namespace haxe{
namespace ui{
namespace backend{

void TextDisplayImpl_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_6_new)
HXLINE(   9)		this->_fontSize = ((Float)14);
HXLINE(  14)		super::__construct();
HXLINE(  15)		this->_fontSize = (( (Float)(14) ) * ::haxe::ui::Toolkit_obj::get_scale());
            	}

Dynamic TextDisplayImpl_obj::__CreateEmpty() { return new TextDisplayImpl_obj; }

void *TextDisplayImpl_obj::_hx_vtable = 0;

Dynamic TextDisplayImpl_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< TextDisplayImpl_obj > _hx_result = new TextDisplayImpl_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool TextDisplayImpl_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x4833349b) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x4833349b;
	} else {
		return inClassId==(int)0x6d6dcab4;
	}
}

bool TextDisplayImpl_obj::validateStyle(){
            	HX_GC_STACKFRAME(&_hx_pos_8071faafd25b045f_21_validateStyle)
HXLINE(  22)		bool measureTextRequired = false;
HXLINE(  24)		if (hx::IsNotNull( this->_textStyle )) {
HXLINE(  25)			if ((this->_textAlign != this->_textStyle->textAlign)) {
HXLINE(  26)				this->_hx_set__textAlign(HX_CTX, this->_textStyle->textAlign);
            			}
HXLINE(  29)			bool _hx_tmp;
HXDLIN(  29)			if (hx::IsNotNull( this->_textStyle->fontSize )) {
HXLINE(  29)				_hx_tmp = hx::IsNotEq( this->_fontSize,this->_textStyle->fontSize );
            			}
            			else {
HXLINE(  29)				_hx_tmp = false;
            			}
HXDLIN(  29)			if (_hx_tmp) {
HXLINE(  30)				 ::Dynamic _hx_tmp1 = this->_textStyle->fontSize;
HXDLIN(  30)				this->_fontSize = (( (Float)(_hx_tmp1) ) * ::haxe::ui::Toolkit_obj::get_scale());
HXLINE(  31)				measureTextRequired = true;
            			}
HXLINE(  34)			bool _hx_tmp2;
HXDLIN(  34)			bool _hx_tmp3;
HXDLIN(  34)			if ((this->_fontName != this->_textStyle->fontName)) {
HXLINE(  34)				_hx_tmp3 = hx::IsNotNull( this->_fontInfo );
            			}
            			else {
HXLINE(  34)				_hx_tmp3 = false;
            			}
HXDLIN(  34)			if (_hx_tmp3) {
HXLINE(  34)				_hx_tmp2 = hx::IsNotEq( this->_fontInfo->__Field(HX_("data",2a,56,63,42),hx::paccDynamic),this->_font );
            			}
            			else {
HXLINE(  34)				_hx_tmp2 = false;
            			}
HXDLIN(  34)			if (_hx_tmp2) {
HXLINE(  35)				this->_hx_set__font(HX_CTX, ( ( ::kha::Kravur)(this->_fontInfo->__Field(HX_("data",2a,56,63,42),hx::paccDynamic)) ));
HXLINE(  36)				measureTextRequired = true;
            			}
HXLINE(  39)			if (hx::IsNotEq( this->_color,this->_textStyle->color )) {
HXLINE(  40)				this->_color = ( (int)(this->_textStyle->color) );
            			}
            		}
HXLINE(  44)		return measureTextRequired;
            	}


void TextDisplayImpl_obj::validateDisplay(){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_47_validateDisplay)
HXLINE(  48)		bool _hx_tmp;
HXDLIN(  48)		if ((this->_width == 0)) {
HXLINE(  48)			_hx_tmp = (this->_textWidth > 0);
            		}
            		else {
HXLINE(  48)			_hx_tmp = false;
            		}
HXDLIN(  48)		if (_hx_tmp) {
HXLINE(  49)			this->_width = this->_textWidth;
            		}
HXLINE(  51)		bool _hx_tmp1;
HXDLIN(  51)		if ((this->_height == 0)) {
HXLINE(  51)			_hx_tmp1 = (this->_textHeight > 0);
            		}
            		else {
HXLINE(  51)			_hx_tmp1 = false;
            		}
HXDLIN(  51)		if (_hx_tmp1) {
HXLINE(  52)			this->_height = this->_textHeight;
            		}
            	}


void TextDisplayImpl_obj::measureText(){
            	HX_GC_STACKFRAME(&_hx_pos_8071faafd25b045f_57_measureText)
HXLINE(  58)		bool _hx_tmp;
HXDLIN(  58)		bool _hx_tmp1;
HXDLIN(  58)		if (hx::IsNotNull( this->_text )) {
HXLINE(  58)			_hx_tmp1 = (this->_text.length == 0);
            		}
            		else {
HXLINE(  58)			_hx_tmp1 = true;
            		}
HXDLIN(  58)		if (!(_hx_tmp1)) {
HXLINE(  58)			_hx_tmp = hx::IsNull( this->_font );
            		}
            		else {
HXLINE(  58)			_hx_tmp = true;
            		}
HXDLIN(  58)		if (_hx_tmp) {
HXLINE(  59)			this->_textWidth = ( (Float)(0) );
HXLINE(  60)			this->_textHeight = ( (Float)(0) );
HXLINE(  61)			return;
            		}
HXLINE(  64)		if ((this->_width <= 0)) {
HXLINE(  65)			this->_hx_set__lines(HX_CTX, ::Array_obj< ::String >::__new());
HXLINE(  66)			this->_lines->push(this->_text);
HXLINE(  67)			 ::kha::Kravur _hx_tmp2 = this->_font;
HXDLIN(  67)			int _hx_tmp3 = ::Std_obj::_hx_int(this->_fontSize);
HXDLIN(  67)			this->_textWidth = _hx_tmp2->width(_hx_tmp3,this->_text);
HXLINE(  68)			 ::kha::Kravur _hx_tmp4 = this->_font;
HXDLIN(  68)			this->_textHeight = _hx_tmp4->height(::Std_obj::_hx_int(this->_fontSize));
HXLINE(  69)			return;
            		}
HXLINE(  73)		Float maxWidth = this->_width;
HXDLIN(  73)		Float maxWidth1 = (maxWidth * ::haxe::ui::Toolkit_obj::get_scale());
HXLINE(  74)		this->_hx_set__lines(HX_CTX, ::Array_obj< ::String >::__new());
HXLINE(  75)		::Array< ::String > lines = this->_text.split(HX_("\n",0a,00,00,00));
HXLINE(  76)		Float biggestWidth = ( (Float)(0) );
HXLINE(  77)		{
HXLINE(  77)			int _g = 0;
HXDLIN(  77)			while((_g < lines->length)){
HXLINE(  77)				::String line = lines->__get(_g);
HXDLIN(  77)				_g = (_g + 1);
HXLINE(  78)				 ::kha::Kravur tw = this->_font;
HXDLIN(  78)				Float tw1 = tw->width(::Std_obj::_hx_int(this->_fontSize),line);
HXLINE(  79)				if ((tw1 > maxWidth1)) {
HXLINE(  80)					 ::haxe::ds::List words = ::Lambda_obj::list(line.split(HX_(" ",20,00,00,00)));
HXLINE(  81)					while(!(words->isEmpty())){
HXLINE(  82)						line = ( (::String)(words->pop()) );
HXLINE(  83)						 ::kha::Kravur tw2 = this->_font;
HXDLIN(  83)						tw1 = tw2->width(::Std_obj::_hx_int(this->_fontSize),line);
HXLINE(  84)						biggestWidth = ::Math_obj::max(biggestWidth,tw1);
HXLINE(  85)						::String nextWord = ( (::String)(words->pop()) );
HXLINE(  86)						while(true){
HXLINE(  86)							bool _hx_tmp5;
HXDLIN(  86)							if (hx::IsNotNull( nextWord )) {
HXLINE(  86)								 ::kha::Kravur tw3 = this->_font;
HXDLIN(  86)								tw1 = tw3->width(::Std_obj::_hx_int(this->_fontSize),((line + HX_(" ",20,00,00,00)) + nextWord));
HXDLIN(  86)								_hx_tmp5 = (tw1 <= maxWidth1);
            							}
            							else {
HXLINE(  86)								_hx_tmp5 = false;
            							}
HXDLIN(  86)							if (!(_hx_tmp5)) {
HXLINE(  86)								goto _hx_goto_5;
            							}
HXLINE(  87)							biggestWidth = ::Math_obj::max(biggestWidth,tw1);
HXLINE(  88)							line = (line + (HX_(" ",20,00,00,00) + nextWord));
HXLINE(  89)							nextWord = ( (::String)(words->pop()) );
            						}
            						_hx_goto_5:;
HXLINE(  91)						this->_lines->push(line);
HXLINE(  92)						if (hx::IsNotNull( nextWord )) {
HXLINE(  93)							words->push(nextWord);
            						}
            					}
            				}
            				else {
HXLINE(  97)					biggestWidth = ::Math_obj::max(biggestWidth,tw1);
HXLINE(  98)					if ((line != HX_("",00,00,00,00))) {
HXLINE(  99)						this->_lines->push(line);
            					}
            				}
            			}
            		}
HXLINE( 104)		this->_textWidth = (biggestWidth / ::haxe::ui::Toolkit_obj::get_scale());
HXLINE( 105)		 ::kha::Kravur _hx_tmp6 = this->_font;
HXDLIN( 105)		Float _hx_tmp7 = _hx_tmp6->height(::Std_obj::_hx_int(this->_fontSize));
HXDLIN( 105)		Float _hx_tmp8 = (_hx_tmp7 * ( (Float)(this->_lines->length) ));
HXDLIN( 105)		this->_textHeight = (_hx_tmp8 / ::haxe::ui::Toolkit_obj::get_scale());
            	}


void TextDisplayImpl_obj::renderTo( ::kha::graphics2::Graphics g,Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_8071faafd25b045f_109_renderTo)
HXDLIN( 109)		if (hx::IsNotNull( this->_lines )) {
HXLINE( 110)			g->set_font(this->_font);
HXLINE( 111)			g->set_fontSize(::Std_obj::_hx_int(this->_fontSize));
HXLINE( 113)			Float ty = (y + this->_top);
HXLINE( 114)			{
HXLINE( 114)				int _g = 0;
HXDLIN( 114)				::Array< ::String > _g1 = this->_lines;
HXDLIN( 114)				while((_g < _g1->length)){
HXLINE( 114)					::String line = _g1->__get(_g);
HXDLIN( 114)					_g = (_g + 1);
HXLINE( 115)					Float tx = x;
HXLINE( 117)					::String _hx_switch_0 = this->_textAlign;
            					if (  (_hx_switch_0==HX_("center",d5,25,db,05)) ){
HXLINE( 119)						Float tx1 = (this->_width - this->_textWidth);
HXDLIN( 119)						tx = (tx + ((tx1 * ::haxe::ui::Toolkit_obj::get_scale()) / ( (Float)(2) )));
HXDLIN( 119)						goto _hx_goto_8;
            					}
            					if (  (_hx_switch_0==HX_("right",dc,0b,64,e9)) ){
HXLINE( 122)						Float tx2 = (this->_width - this->_textWidth);
HXDLIN( 122)						tx = (tx + (tx2 * ::haxe::ui::Toolkit_obj::get_scale()));
HXDLIN( 122)						goto _hx_goto_8;
            					}
            					/* default */{
HXLINE( 125)						tx = (tx + this->_left);
            					}
            					_hx_goto_8:;
HXLINE( 128)					g->drawString(line,tx,ty);
HXLINE( 129)					 ::kha::Kravur ty1 = this->_font;
HXDLIN( 129)					ty = (ty + ty1->height(::Std_obj::_hx_int(this->_fontSize)));
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(TextDisplayImpl_obj,renderTo,(void))


hx::ObjectPtr< TextDisplayImpl_obj > TextDisplayImpl_obj::__new() {
	hx::ObjectPtr< TextDisplayImpl_obj > __this = new TextDisplayImpl_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< TextDisplayImpl_obj > TextDisplayImpl_obj::__alloc(hx::Ctx *_hx_ctx) {
	TextDisplayImpl_obj *__this = (TextDisplayImpl_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(TextDisplayImpl_obj), true, "haxe.ui.backend.TextDisplayImpl"));
	*(void **)__this = TextDisplayImpl_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

TextDisplayImpl_obj::TextDisplayImpl_obj()
{
}

void TextDisplayImpl_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(TextDisplayImpl);
	HX_MARK_MEMBER_NAME(_font,"_font");
	HX_MARK_MEMBER_NAME(_textAlign,"_textAlign");
	HX_MARK_MEMBER_NAME(_fontSize,"_fontSize");
	HX_MARK_MEMBER_NAME(_fontName,"_fontName");
	HX_MARK_MEMBER_NAME(_color,"_color");
	HX_MARK_MEMBER_NAME(_lines,"_lines");
	 ::haxe::ui::backend::TextBase_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void TextDisplayImpl_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(_font,"_font");
	HX_VISIT_MEMBER_NAME(_textAlign,"_textAlign");
	HX_VISIT_MEMBER_NAME(_fontSize,"_fontSize");
	HX_VISIT_MEMBER_NAME(_fontName,"_fontName");
	HX_VISIT_MEMBER_NAME(_color,"_color");
	HX_VISIT_MEMBER_NAME(_lines,"_lines");
	 ::haxe::ui::backend::TextBase_obj::__Visit(HX_VISIT_ARG);
}

hx::Val TextDisplayImpl_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_font") ) { return hx::Val( _font ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_color") ) { return hx::Val( _color ); }
		if (HX_FIELD_EQ(inName,"_lines") ) { return hx::Val( _lines ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"renderTo") ) { return hx::Val( renderTo_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_fontSize") ) { return hx::Val( _fontSize ); }
		if (HX_FIELD_EQ(inName,"_fontName") ) { return hx::Val( _fontName ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_textAlign") ) { return hx::Val( _textAlign ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"measureText") ) { return hx::Val( measureText_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"validateStyle") ) { return hx::Val( validateStyle_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"validateDisplay") ) { return hx::Val( validateDisplay_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val TextDisplayImpl_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"_font") ) { _hx_set__font(HX_CTX_GET,inValue.Cast<  ::kha::Kravur >()); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"_color") ) { _color=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_lines") ) { _hx_set__lines(HX_CTX_GET,inValue.Cast< ::Array< ::String > >()); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"_fontSize") ) { _fontSize=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_fontName") ) { _hx_set__fontName(HX_CTX_GET,inValue.Cast< ::String >()); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"_textAlign") ) { _hx_set__textAlign(HX_CTX_GET,inValue.Cast< ::String >()); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void TextDisplayImpl_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("_font",ae,79,d1,f6));
	outFields->push(HX_("_textAlign",99,62,21,16));
	outFields->push(HX_("_fontSize",8f,b5,67,16));
	outFields->push(HX_("_fontName",19,87,13,13));
	outFields->push(HX_("_color",a4,b8,43,46));
	outFields->push(HX_("_lines",40,25,e9,70));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo TextDisplayImpl_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*  ::kha::Kravur */ ,(int)offsetof(TextDisplayImpl_obj,_font),HX_("_font",ae,79,d1,f6)},
	{hx::fsString,(int)offsetof(TextDisplayImpl_obj,_textAlign),HX_("_textAlign",99,62,21,16)},
	{hx::fsFloat,(int)offsetof(TextDisplayImpl_obj,_fontSize),HX_("_fontSize",8f,b5,67,16)},
	{hx::fsString,(int)offsetof(TextDisplayImpl_obj,_fontName),HX_("_fontName",19,87,13,13)},
	{hx::fsInt,(int)offsetof(TextDisplayImpl_obj,_color),HX_("_color",a4,b8,43,46)},
	{hx::fsObject /* ::Array< ::String > */ ,(int)offsetof(TextDisplayImpl_obj,_lines),HX_("_lines",40,25,e9,70)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *TextDisplayImpl_obj_sStaticStorageInfo = 0;
#endif

static ::String TextDisplayImpl_obj_sMemberFields[] = {
	HX_("_font",ae,79,d1,f6),
	HX_("_textAlign",99,62,21,16),
	HX_("_fontSize",8f,b5,67,16),
	HX_("_fontName",19,87,13,13),
	HX_("_color",a4,b8,43,46),
	HX_("validateStyle",bb,64,1d,b0),
	HX_("validateDisplay",4c,60,60,b6),
	HX_("_lines",40,25,e9,70),
	HX_("measureText",2b,fb,80,50),
	HX_("renderTo",71,b6,db,b2),
	::String(null()) };

hx::Class TextDisplayImpl_obj::__mClass;

void TextDisplayImpl_obj::__register()
{
	TextDisplayImpl_obj _hx_dummy;
	TextDisplayImpl_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("haxe.ui.backend.TextDisplayImpl",49,fd,9e,50);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(TextDisplayImpl_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< TextDisplayImpl_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TextDisplayImpl_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TextDisplayImpl_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace ui
} // end namespace backend
